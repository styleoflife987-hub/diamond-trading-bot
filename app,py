import os
import uuid
from datetime import datetime
from io import BytesIO

import boto3
from boto3.dynamodb.conditions import Key
from openai import OpenAI
from fastapi import FastAPI
from fastapi.responses import HTMLResponse
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters
)

# ========================
# ENV VARIABLES
# ========================

BOT_TOKEN = os.getenv("BOT_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

AWS_REGION = os.getenv("AWS_REGION")
S3_BUCKET = os.getenv("S3_BUCKET")

if not BOT_TOKEN or not AWS_REGION:
    raise Exception("‚ùå Missing environment variables")

# ========================
# AWS CLIENTS
# ========================

session = boto3.Session(region_name=AWS_REGION)

dynamodb = session.resource("dynamodb")
s3 = session.client("s3")

users_table = dynamodb.Table("diamond_users")
diamonds_table = dynamodb.Table("diamond_diamonds")
orders_table = dynamodb.Table("diamond_orders")
payments_table = dynamodb.Table("diamond_payments")

# ========================
# OPENAI
# ========================

client_ai = OpenAI(api_key=OPENAI_API_KEY)

async def ai_reply(text: str):
    try:
        r = client_ai.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": text}],
            max_tokens=200
        )
        return r.choices[0].message.content
    except Exception as e:
        print("AI Error:", e)
        return "‚ö†Ô∏è AI temporarily unavailable."

# ========================
# FASTAPI
# ========================

app = FastAPI()

@app.get("/")
def home():
    return {"status": "AWS Bot running üöÄ"}

# ========================
# ADMIN DASHBOARD
# ========================

@app.get("/dashboard", response_class=HTMLResponse)
def dashboard():
    users = users_table.scan()["Count"]
    diamonds = diamonds_table.scan()["Count"]
    orders = orders_table.scan()["Count"]
    payments = payments_table.scan()["Count"]

    return f"""
    <h1>üíé Diamond Admin Dashboard</h1>
    <ul>
        <li>Users: {users}</li>
        <li>Diamonds: {diamonds}</li>
        <li>Orders: {orders}</li>
        <li>Payments: {payments}</li>
    </ul>
    """

# ========================
# STORAGE
# ========================

user_state = {}
temp_data = {}
users = {}

# ========================
# AUTO PRICE MATCHING
# ========================

def auto_price_match(name, price):
    items = diamonds_table.scan().get("Items", [])
    same = [d for d in items if d["name"].lower() == name.lower()]

    if len(same) < 2:
        return price

    avg = sum(float(d["price"]) for d in same) / len(same)
    return round(min(price, avg * 0.98), 2)

# ========================
# ADMIN AUTO CREATE
# ========================

def ensure_admin():
    try:
        users_table.get_item(Key={"username": "admin"})["Item"]
    except:
        users_table.put_item(Item={
            "username": "admin",
            "password": "admin123",
            "role": "admin",
            "approved": True,
            "telegram_id": None
        })

ensure_admin()

# ========================
# KEYBOARDS
# ========================

def supplier_kb():
    return ReplyKeyboardMarkup(
        [["üíé Add Diamond", "üì¶ My Stock"], ["üìä Analytics"]],
        resize_keyboard=True
    )

def client_kb():
    return ReplyKeyboardMarkup(
        [["üîç View Diamonds", "üõí My Orders"]],
        resize_keyboard=True
    )

# ========================
# FILE UPLOAD TO S3
# ========================

def upload_to_s3(file_bytes, filename):
    key = f"diamonds/{uuid.uuid4()}-{filename}"
    s3.put_object(Bucket=S3_BUCKET, Key=key, Body=file_bytes)
    return f"https://{S3_BUCKET}.s3.{AWS_REGION}.amazonaws.com/{key}"

# ========================
# START
# ========================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_state[update.effective_user.id] = "menu"
    await update.message.reply_text("1 Register\n2 Login")

# ========================
# MAIN ROUTER
# ========================

async def main_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    text = update.message.text.strip()
    state = user_state.get(uid)

    # ---------------- MENU ----------------
    if state == "menu":
        if text == "1":
            user_state[uid] = "reg_user"
            temp_data[uid] = {}
            await update.message.reply_text("Username:")
        elif text == "2":
            user_state[uid] = "login_user"
            await update.message.reply_text("Username:")
        return

    # ---------------- REGISTER ----------------
    if state == "reg_user":
        temp_data[uid]["username"] = text
        user_state[uid] = "reg_pass"
        await update.message.reply_text("Password:")
        return

    if state == "reg_pass":
        users_table.put_item(Item={
            "username": temp_data[uid]["username"],
            "password": text,
            "role": "client",
            "approved": False,
            "telegram_id": None
        })
        user_state[uid] = "menu"
        await update.message.reply_text("‚úÖ Registered. Wait admin approval.")
        return

    # ---------------- LOGIN ----------------
    if state == "login_user":
        temp_data[uid] = {"username": text}
        user_state[uid] = "login_pass"
        await update.message.reply_text("Password:")
        return

    if state == "login_pass":
        try:
            acc = users_table.get_item(
                Key={"username": temp_data[uid]["username"]}
            )["Item"]
        except:
            await update.message.reply_text("‚ùå User not found")
            user_state[uid] = "menu"
            return

        if acc["password"] != text:
            await update.message.reply_text("‚ùå Invalid password")
            user_state[uid] = "menu"
            return

        acc["telegram_id"] = uid
        users_table.put_item(Item=acc)

        users[uid] = acc
        user_state[uid] = acc["role"]

        kb = supplier_kb() if acc["role"] == "supplier" else client_kb()
        await update.message.reply_text("‚úÖ Logged in", reply_markup=kb)
        return

    # ---------------- SUPPLIER ----------------
    if state == "supplier":
        if text == "üíé Add Diamond":
            user_state[uid] = "add_name"
            await update.message.reply_text("Diamond name:")
            return

        if text == "üìä Analytics":
            diamonds = diamonds_table.scan()["Items"]
            my = [d for d in diamonds if d["supplier"] == users[uid]["username"]]
            await update.message.reply_text(f"üì¶ Diamonds: {len(my)}")
            return

    if state == "add_name":
        temp_data[uid] = {"name": text}
        user_state[uid] = "add_price"
        await update.message.reply_text("Price:")
        return

    if state == "add_price":
        price = float(text)
        final_price = auto_price_match(temp_data[uid]["name"], price)

        diamonds_table.put_item(Item={
            "diamond_id": str(uuid.uuid4()),
            "name": temp_data[uid]["name"],
            "price": str(final_price),
            "supplier": users[uid]["username"],
            "created_at": datetime.utcnow().isoformat()
        })

        user_state[uid] = "supplier"
        await update.message.reply_text(f"‚úÖ Diamond added ‚Çπ{final_price}")
        return

    # ---------------- CLIENT ----------------
    if state == "client":
        if text == "üîç View Diamonds":
            diamonds = diamonds_table.scan()["Items"]
            msg = "\n".join([f"{d['name']} - ‚Çπ{d['price']}" for d in diamonds])
            await update.message.reply_text(msg or "No diamonds available")
            return

        ai = await ai_reply(text)
        await update.message.reply_text(ai)

# ========================
# TELEGRAM
# ========================

telegram_app = Application.builder().token(BOT_TOKEN).build()
telegram_app.add_handler(CommandHandler("start", start))
telegram_app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, main_router))

@app.on_event("startup")
async def startup():
    await telegram_app.initialize()
    await telegram_app.start()
    print("‚úÖ Telegram bot started")

@app.on_event("shutdown")
async def shutdown():
    await telegram_app.stop()
    await telegram_app.shutdown()
